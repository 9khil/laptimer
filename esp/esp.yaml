# Current version: v1.2
# Version History
# 1.0 2022-09-13: Initial Version
# 1.1 2022-09-14: Tweak timings to detect distance every 100ms
# 1.2 2022-09-27: Distance sensor now outputs 3 decimal places

esphome:
  name: break-beam-1
  friendly_name: Break beam 1

esp8266:
  board: d1_mini

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "zbpgQmtgPNjrGx3Iuu++CeWB/O4RiKpwpF/Yqb9Sygk="

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "break-beam-1 fallback"
    password: "12345678"

captive_portal:

ota:
  - platform: esphome
    password: "a67566e6e36a8fe8a6962f00adf8f640"

safe_mode:
  disabled: false
  reboot_timeout: 10min
  num_attempts: 5

globals:
  # Set this to the distance detected by the ultrasonic sensor. Default is 2m.
  - id: maximum_distance
    type: float
    initial_value: "0.78"
  # How many distance readings to detect before reporting value (smooth false positives)
  - id: reporting_interval
    type: int
    initial_value: "2"
  # Do not change the following globals
  - id: detected_readings
    type: int
    restore_value: no
    initial_value: "0"
  - id: previous_reading_nan
    type: boolean
    restore_value: no
    initial_value: "true"
  - id: previous_reading
    type: float
    restore_value: no
    initial_value: "20.0"

sensor:
  # This is the physical sensor, not published to Home Assistant
  - platform: ultrasonic
    trigger_pin: D2
    echo_pin: D1
    name: "Ultrasonic Distance Raw"
    update_interval: 100ms
    id: ultrasonic_distance_raw
    internal: true
  # This is a virtual sensor to smooth the false positive readings
  - platform: template
    id: ultrasonic_distance
    name: "Dining Room Break Beam Distance"
    update_interval: 100ms
    accuracy_decimals: 3
    lambda: |-
      ESP_LOGD("Ultrasonic", "Got %d readings in a row", id(detected_readings));
      if (id(ultrasonic_distance_raw).state < id(maximum_distance)) {
        // We have a reading... don't use it, just remember that we got one, but not if we're already at the limit of how many we need
        ESP_LOGD("Ultrasonic", "We have a reading... don't use it, just remember that we got one.");
        if(id(previous_reading_nan) == true) {
          id(previous_reading_nan) = false;
          id(detected_readings) = 0;
        }
        if( id(detected_readings) < id(reporting_interval) ) {
          id(detected_readings) += 1;
        }
      }
      else {
        // We got a NAN reading (out of range). Reset the readings counter
        if(id(previous_reading_nan) == false) {
          id(previous_reading_nan) = true;
          id(detected_readings) = 0;
        }
        if( id(detected_readings) < id(reporting_interval) ) {
          id(detected_readings) += 1;
        }
        ESP_LOGD("Ultrasonic", "We got a NAN reading (out of range). Reset the readings counter");
        id(previous_reading_nan) = true;
      }

      if( id(detected_readings) >= id(reporting_interval)) {
        // We have gathered enough readings in a row to report
        if(id(previous_reading_nan) == false) {
          id(previous_reading) = id(ultrasonic_distance_raw).state;
          return id(ultrasonic_distance_raw).state;
        }
        else {
          ESP_LOGD("Ultrasonic", "We have gathered enough readings in a row to report: %f", id(maximum_distance));
          id(previous_reading) = id(maximum_distance);
          return id(maximum_distance); 
        }
      }
      return id(previous_reading);

binary_sensor:
  - platform: template
    name: "Break Beam 1"
    lambda: |-
      if (id(ultrasonic_distance).state < id(maximum_distance)) {
        // Presence is detected
        return true;
      } else {
        // No presence detected.
        return false;
      }
    filters:
      - delayed_off: 1s
